# 倒排索引 Inverted Index
Elastic search中，每一个`分片shard`都是一个包含了`倒排索引`的底层`Lucene index`。那么究竟什么是倒排索引？它又为什么可以提供如此快速的搜索能力？

首先让我们看一下常见的关系型数据库MySQL是怎样进行索引的。

## MySQL索引
`索引Index`的存在是为了加速搜索，我们很容易想到可以用`Binary Search Tree二叉搜索树`来实现$O(\log_2(n))$的时间复杂度。实际上MySQL的底层索引使用更巧妙一些的`B+Tree`来实现。

`B+Tree`是一棵自平衡数，它所有叶子节点都在同一高度，所有叶子节点排序相连形成一个`链表Linked list`。每一个节点拥有一个到多个检索key，任意两个keys之间是一个左封闭的区间，当查询值落入该区间则进入对应的子节点，直到在叶子节点中找到查询值对应的数据。
![bplustree](/figures/bplustree.png)

B+Tree的优点是：
- `相比起一般的BST`很容易坍缩为一个链表，从而使复杂度变回$O(n)$，B+Tree是自平衡的，它保证所有叶子节点在同一高度；
- `相比起自平衡的AVL Tree`当数据过大时很容易过高，从而导致对节点的频繁访问。由于MySQL的检索是存储在磁盘上的，每一次节点的访问实际上都是一次读取。磁盘IO所消耗的时间要远远超过数据处理本身所花费的时间。所以B+Tree每个node有多个key，这大大降低了树的高度；
- `相比起自平衡多键值的B-Tree`：
  - B+Tree在非叶子节点只保存索引，而将数据保存在叶子节点。这样保证了每个非叶子节点可以保存更多键值，而叶子节点可以保存更多数据。同时根据磁盘IO的读写能力进行优化，单次IO尽可能读取更多的数据；
  - B+Tree的叶子节点顺序相连，这样在扫表时就避免了像B-Tree一样需要遍历整棵树，从而大大加快扫表速度；

然而面对海量数据的全文检索时，B+Tree的局限性在于：
- 每一次搜索时都需要从根节点走到叶子节点，需要大量的磁盘IO开销，无法做到实时；
- 基于分词的全文检索时（e.g. `SELECT * from table WHERE content="%WTO%"`），因为索引失效，会进行全表检索，效率大大降低。

所以我们使用`倒排索引Inverted Index`来解决这个问题。

## 倒排索引Inverted Context

一个`倒排索引`实际上是一个`dictionary`，将分词后文档中每一个不重复的term映射到所有包含它的文档组成的列表。

![inverted_index](/figures/inverted_index.png)

当进行全文搜索时，我们根据query中的terms找到对应的一组文档列表，计算每一篇document的相关性进而进行排序。默认情况下，`relevance score`的计算使用`TF-IDF`，所以我们会保存每个term在每篇document中出现的`frequency`。

Lucene将倒排索引放在内存中，相比磁盘这大大加快了读取的效率（同时Elasticsearch也非常吃内存）。同时倒排索引是分词后进行的，面对全文搜索时索引不会失效。