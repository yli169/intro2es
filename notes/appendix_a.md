# 倒排索引 Inverted Index
Elastic search 中，每一个`分片 shard` 都是一个包含了`倒排索引`的底层 `Lucene index`。那么究竟什么是倒排索引？它又为什么可以提供如此快速的搜索能力？

首先让我们看一下常见的关系型数据库MySQL是怎样进行索引的。

## MySQL 索引
`索引 Index` 的存在是为了加速搜索，我们很容易想到可以用 `Binary Search Tree 二叉搜索树`来实现 $O(\log_2(n))$ 的时间复杂度。实际上MySQL的底层索引使用更巧妙一些的 `B+Tree` 来实现。

`B+Tree` 是一棵自平衡数，它所有叶子节点都在同一高度，所有叶子节点排序相连形成一个`链表 Linked list`。每一个节点拥有一个到多个检索 key，任意两个 keys 之间是一个左封闭的区间，当查询值落入该区间则进入对应的子节点，直到在叶子节点中找到查询值对应的数据。
![bplustree](/figures/bplustree.png)

B+Tree 的优点是：
- `相比起一般的 BST` 很容易坍缩为一个链表，从而使复杂度变回 $O(n)$，B+Tree 是自平衡的，它保证所有叶子节点在同一高度；
- `相比起自平衡的 AVL Tree` 当数据过大时很容易过高，从而导致对节点的频繁访问。由于 MySQL 的检索是存储在磁盘上的，每一次节点的访问实际上都是一次读取。磁盘IO所消耗的时间要远远超过数据处理本身所花费的时间。所以 B+Tree 每个 node 有多个 keys，这大大降低了树的高度；
- `相比起自平衡多键值的 B-Tree`：
  - B+Tree 在非叶子节点只保存索引，而将数据保存在叶子节点。这样保证了每个非叶子节点可以保存更多键值，而叶子节点可以保存更多数据。同时根据磁盘IO的读写能力进行优化，单次IO尽可能读取更多的数据；
  - B+Tree 的叶子节点顺序相连，这样在扫表时就避免了像 B-Tree 一样需要遍历整棵树，从而大大加快扫表速度；

然而面对海量数据的全文检索时，B+Tree 的局限性在于：
- 每一次搜索时都需要从根节点走到叶子节点，需要大量的磁盘IO开销，无法做到实时；
- 基于分词的全文检索时（e.g. `SELECT * from table WHERE content="%WTO%"` ），因为索引失效，会进行全表检索，效率大大降低。

所以我们使用`倒排索引 Inverted Index` 来解决这个问题。

## 倒排索引 Inverted Context

一个`倒排索引`实际上是一个 `dictionary`，将分词后文档中每一个不重复的 term 映射到所有包含它的文档组成的列表。

![inverted_index](/figures/inverted_index.png)

当进行全文搜索时，我们根据 query 中的 terms 找到对应的一组文档列表，计算每一篇 document 的相关性进而进行排序。默认情况下，`relevance score` 的计算使用 `TF-IDF`，所以我们会保存每个term在每篇 document 中出现的 `frequency`。

Lucene 将倒排索引放在内存中，相比磁盘这大大加快了读取的效率（同时 Elasticsearch 也非常吃内存）。同时倒排索引是分词后进行的，面对全文搜索时索引不会失效。